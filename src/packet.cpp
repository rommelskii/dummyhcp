#include <iostream>
#include <vector>
#include <unordered_map>

/*
struct __attribute__((packed)) dhcp_header {
    uint8_t     op;             // Type of operation: 1 = BOOTREQUEST, 2 = BOOTREPLY
    uint8_t     htype;          // Hardware type: 1 = Ethernet
    uint8_t     hlen;           // Hardware address length: 6 bytes
    uint8_t     hops;           // 0 since no helper address
    uint32_t    xid;            // Generated by client, used by server for state tracking
    uint16_t    secs;           // Lease time as a 16-bit unsigned integer
    uint16_t    flags;          // 0 for unicast server reply, 1 for broadcast client discovery
    uint32_t    ciaddr;         // Client IP, 0.0.0.0 for discovery
    uint32_t    yiaddr;         // Leased address from server
    uint32_t    siaddr;         // Next server for bootstrap server
    uint32_t    giaddr;         // Gateway address for the end hosts
    uint8_t     chaddr[16];     // Client MAC address
    uint8_t     sname[64];      // Server hostname, all 0 if unused
    uint8_t     file[128];      // Directory and path of the boot file
    uint32_t    magic_cookie;   // 0x63825363
};
*/

const uint32_t MAGIC_COOKIE = 0x63825363;


void dhcp_packet::build_header(uint8_t op, uint32_t xid, uint16_t secs, uint16_t flags,
                  uint32_t ciaddr, uint32_t yiaddr, uint32_t siaddr,
                  uint32_t giaddr, uint8_t chaddr[16]) {
  dhcp_packet dp = dhcp_packet();

  dp.header.op = op;
  dp.header.htype = 1;
  dp.header.hlen = 6;
  dp.header.hops = 0;
  dp.header.xid = xid;
  dp.header.secs = secs;
  dp.header.flags = flags;
  dp.header.ciaddr = ciaddr;
  dp.header.yiaddr = yiaddr;
  dp.header.siaddr = siaddr;
  dp.header.giaddr = giaddr;

  std::memcpy(chaddr, dp.header.chaddr, sizeof(chaddr));
  std::memset(dp.header.sname, 0, sizeof(dp.header.sname));
  std::memset(dp.header.file, 0, sizeof(dp.header.file));

  dp.header.magic_cookie = MAGIC_COOKIE;

  this->header = dp;
}

struct dhcp_header dhcp_packet::preflight_order_change(struct dhcp_header dh) {
  dhcp_header temp_dh = this->header;
  temp_dh.xid = htonl(temp_dh.xid);
  temp_dh.secs = htonl(temp_dh.secs);
  temp_dh.flags = htonl(temp_dh.flags);
  temp_dh.ciaddr = htonl(temp_dh.ciaddr);
  temp_dh.yiaddr = htonl(temp_dh.yiaddr);
  temp_dh.siaddr = htonl(temp_dh.siaddr);
  temp_dh.giaddr = htonl(temp_dh.giaddr);
  temp_dh.magic_cookie = htonl(temp_dh.magic_cookie);
  this->header = temp_dh;
  return temp_dh;
}

ssize_t dhcp_packet::serialize(uint8_t buf[], size_t max_len) {
  this.preflight_order_change(); //change appropriate packet fields to network order
  // begin copying header to byte buffer
  std::memcpy(this.header, buf, sizeof(this.header));

  ssize_t offset = &buf[0] + sizeof(this.header); // create pointer after header
  for (const auto& [type, value] : this->options) {
    if (offset + 2 + value.size() > (size_t)max_len) return -1; // boundary check if payload is within length specified

    buf[offset++] = type;
    buf[offset++] = (uint8_t)value.size();

    std::memcpy(buf + offset, value.data(), value.size()); // copy the variable-sized option value field to the buffer
    offset += value.size();
  }

  if (offset < (size_t)max_len) {
    buf[offset++] = 0xFF;
  } else {
    return -1;
  }

  return (ssize_t)offset;
}

ssize_t dhcp_packet::deserialize(uint8_t buf[], size_t bytes_received) {
  if (bytes_received < sizeof(this->header)) {
    std::cerr << "error: header size mismatch";
    return -1;
  }
  std::memcpy(buf, this->header, sizeof(this->header)); // extract header from bytes to header

  const uint8_t* options_start = buf + sizeof(this->header); // pointer where options field starts
  const uint8_t* options_end = buf + bytes_received;
  uint8_t* current = option_start;
  while (current < options_end) {
    if (type == 255) break; // stop if 0xFF (end of options)
    if (type == 0) { // skip 0 padding
      current++;
      continue;
    } 
    uint8_t* value_length = current + 1;
    if ((current + 2 + value_length) > options_end) {
      std::cerr << "error: options length mismatch";
      break;
    }
    for (int i=0; i<value_length; ++i) {
      this->options[type].push_back(*current + 2 + i);
    }
    current += (2 + value_length);
  }

  if (current != options_end) {
    return -1;
  }

  return current;
}
