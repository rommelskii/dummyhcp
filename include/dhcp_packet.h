//
// Created by MJ Ronduen on 1/14/26.
//

#ifndef DHCP_DHCP_PACKET_H
#define DHCP_DHCP_PACKET_H

#define MAXSIZE 1500

#include <unordered_map>
#include <vector>


enum host_type {
    DHCP_SERVER,
    DHCP_CLIENT
};

enum client_state {
    CLIENT_BOUND,
    CLIENT_UNBOUND
};

// __attribute__((packed)) removes padding
/**
 * Note: all contents here are in host order. Ensure that fields are in network order
 *       before forwarding outside the socket.
 */
struct __attribute__((packed)) dhcp_header {
    uint8_t     op;             // Type of operation: 1 = BOOTREQUEST, 2 = BOOTREPLY
    uint8_t     htype;          // Hardware type: 1 = Ethernet
    uint8_t     hlen;           // Hardware address length: 6 bytes
    uint8_t     hops;           // 0 since no helper address
    uint32_t    xid;            // Generated by client, used by server for state tracking
    uint16_t    secs;           // Lease time as a 16-bit unsigned integer
    uint16_t    flags;          // 0 for unicast server reply, 1 for broadcast client discovery
    uint32_t    ciaddr;         // Client IP, 0.0.0.0 for discovery
    uint32_t    yiaddr;         // Leased address from server
    uint32_t    siaddr;         // Next server for bootstrap server
    uint32_t    giaddr;         // Gateway address for the end hosts
    uint8_t     chaddr[16];     // Client MAC address
    uint8_t     sname[64];      // Server hostname, all 0 if unused
    uint8_t     file[128];      // Directory and path of the boot file
    uint32_t    magic_cookie;   // 0x63825363
};

class dhcp_packet {
public:
    dhcp_header header;
    std::unordered_map<uint8_t, std::vector<uint8_t> > options;

    void packet_from_stream(uint8_t buffer[MAXSIZE], ssize_t bytes_received);
    void build_client_header(uint32_t ciaddr, uint32_t giaddr, uint32_t xid, uint8_t mac[8]);
    ssize_t serialize(uint8_t buf[], ssize_t max_len);
};

std::string mac_to_string(uint8_t mac[16]);


#endif //DHCP_DHCP_PACKET_H